## 문제
- `n` : XX산의 지점 수
- `paths` : 각 등산로의 정보를 담은 2차원 정수 배열
- `gates` : 출입구들의 번호가 담긴 정수 배열
- `summits` : 산봉우리들의 번호가 담긴 정수 배열
- `intensity` : 휴식 없이 이동해야 하는 시간 중 가장 긴 시간
- 출입구 중 한 곳 → 산봉우리 중 한 곳 → 원래의 출입구
- intensity가 최소가 되는 등산코스 리턴, 여러 개라면 그중 산봉우리의 번호가 가장 낮은 코스 선택

## 풀이
- `set` : 산봉우리 빨리 찾기 위해 사용
- `intensity` : 각 지점에서 가장 긴 시간
- 출입구에서 시간은 0이므로 for문 돌면서 저장
- 다익스트라
    - queue → 시간을 기준으로 오름차순 정렬, 최단 경로가 먼저 나오도록 저장한다.
    - 만약 현재 위치가 봉우리라면 더이상 탐색하지 않는다.
    - 만약 현재 시간이 저장되어있는 시간보다 크다면 탐색하지 않는다.
    - graph 돌면서 둘(intensity[cur[0]], next[1]) 중 max값을 찾고, 그 값이 현재 저장된 값보다 작으면 갱신
