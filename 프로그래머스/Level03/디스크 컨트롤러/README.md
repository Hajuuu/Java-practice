## 문제
- 대기 큐 : [작업 번호, 작업 요청 시각, 작업 소요 시간]
- 디스크 컨트롤러는 하드디스크가 작업을 하고 있지 않고 대기 큐가 비어있지 않다면 가장 우선순위가 높은 작업을 대기큐에서 꺼내서 하드디스크에 그 작업을 시킨다.
- 우선순위
    - 작업의 소요시간이 짧은 것
    - 작업의 요청시각이 빠른 것
    - 작업의 번호가 작은 것
- 하드디스크는 작업을 한 번 시작하면 작업을 마칠 때까지 그 작업만 수행함
- 하드디스크가 어떤 작업을 마치는 시점과 다른 작업 요청이 들어오는 시점이 겹치든 안겹치든 무조건 대기큐에 넣고 끝난다음 꺼내서 작업시킴
- 모든 요청 작업의 반환 시간의 평균을 계산해서 리턴
- `jobs` : [작업이 요청되는 시점, 작업의 소요시간]

## 풀이
- jobs를 요청 시간 순서대로 정렬 → 시간 순서대로 처리
- queue → 소요 시간이 짧은 작업이 먼저 나오도록 정렬
- `count` : 처리한 작업 수
- `index` : jobs 배열의 인덱스
- `currentTime` : 현재 시간
- `totalTime` :  총 대기 시간 (요청 ~ 종료 시간의 합)
- 현재 시점까지 요청된 작업들을 queue에 넣고 index 증가
- 큐가 비어 있다면 도착한 작업이 없다는 의미이므로 다음 요청 시간까지 currentTime 건너뜀
- 이후 가장 소요 시간이 짧은 작업을 꺼내고 currentTime을 현재 작업 시간 만큼 증가시킨다.
- totalTime에 현재 작업까지의 소요 시간(대기 + 실행시간) 더하기

## 복습
- 대기큐 안에 [작업의 번호, 작업의 요청 시각. 작업의 소요 시간] 저장
- 하드디스크가 작업을 하고 있지 않고 대기큐가 비어있지 않다면 가장 우선순위가 높은 작업을 대기 큐에서 꺼내서 작업시킴
- 1. 소요시간 2. 요청 시각 3. 번호 순서대로 우선순위가 높음
- 우선순위큐를 위 순서대로 정렬
- 소요 시간 배열 만든다 -> X 없어도됨
- while문 내부의 for문으로 시간에 맞는 작업들 큐에 넣음
- 우선순위큐에서 작업 하나씩 꺼내고 현재 시간 갱신, 소요시간 추가
**틀렸던 부분**
- jobs는 정렬되어있지 않음, 요청 시점으로 오름차순 정렬
- while문의 break조건 외에도 queue가 비어있을 경우 생각해서 현재 시간 다음 작업으로 건너뛰기 해야됨
- index는 if문 안에서 하나씩 증가시켜야됨 (바깥의 경우는 만약 모든 작업이 if문에 해당할 경우 index가 갱신되지 않음)
