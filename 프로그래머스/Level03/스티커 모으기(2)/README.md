## 문제
- 하나의 스티커를 뜯으면 양쪽의 스티커는 사용할 수 없음
- 스티커를 뜯어내어 얻을 수 있는 숫자의 합의 최댓값 리턴
- 원형의 모양을 위해 배열의 첫 번째 원소와 마지막 원소는 연결되어있다고 가정

## 풀이
- sticker는 길이 100,000의 배열(최대)
- 완전탐색 방식으로 풀이
- visited 배열에 현재 뜯은 스티커 체크하면서 크기 구하기
- 이전 스티커를 뜯었다면 현재 스티커를 뜯을 수 없고, 이전 스티커를 뜯지 않았다면 스티커를 뜯거나 뜯지 않을 수 있다.
- bfs 방식으로 탐색 + PriorityQueue이용해 현재 값이 가장 큰 값을 우선으로 계산한다.
- 만약 idx가 끝에 도달했다면 바로 리턴
- queue : {현재 스티커 인덱스, 현재 점수, 뜯음 여부(0 : 안뜯음, 1 : 뜯음)}
------> X

- DP 방식으로 풀이
- 첫번째 스티커를 떼는 경우와 첫번째 스티커를 떼지 않는 두 가지 경우로 나누어 풀이
- 첫번째 스티커를 떼는 경우 : 마지막 스티커 못뗌
- 첫번째 스티커를 떼지 않는 경우 : 두번째 스티커 떼고 시작
- 각 경우를 따로 두고 계산한다.
- i번째 칸에서의 점수는 i - 1을 뜯거나 i - 2를 뜯은 경우일 때 모두 가능하며 i - 2에서 뜯었다면 현재 스티커의 값을 더하여 둘 중 큰 숫자의 값을 저장한다.
